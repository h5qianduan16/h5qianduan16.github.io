<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas绘制圆]]></title>
    <url>%2F2019%2F07%2F30%2Fcanvas%E7%BB%98%E5%88%B6%E5%9C%86%2F</url>
    <content type="text"><![CDATA[#canvas画圆 123456789101112// 获取到canvas画布的dom对象 var canvas = document.getElementById('canvas'); // 获取上下文（工具库） var ctx = canvas.getContext('2d'); ctx.arc(200, 200,50, 0, Math.PI,false) ctx.stroke() ctx.beginPath() ctx.arc(400,200,50,0,Math.PI*2,false) ctx.stroke() 使用arc()方法来绘制圆，参数分别是：圆心坐标，半径，开始弧度位置，结束弧度位置，顺逆时针。false顺时针。改变弧度的位置可以绘制扇形。效果图 #等分扇形 12345678910111213141516var m=8 for (var i = 0; i &lt;m ; i++) &#123; var PIItem=Math.PI *2 /m; ctx.beginPath() ctx.moveTo(100,100) ctx.arc(100,100,100,PIItem*i,PIItem*(i+1),false) ctx.fillStyle=colorlist(); ctx.fill() &#125; function colorlist() &#123; var r=Math.floor(Math.random()*256) var g=Math.floor(Math.random()*256) var b=Math.floor(Math.random()*256) return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)` &#125; 效果图 123456789101112131415161718192021222324252627282930var data=[10,20,30,40,50,60]var totals= data.reduce(function (pre,cur) &#123; pre=pre+cur return pre &#125;,0); var arr=[] data.forEach(function (item) &#123; arr.push(item/totals) &#125;) function drawPie(x,y,r,a) &#123; var beginr=0; var endr=0; for (var i = 0; i &lt;a.length ; i++) &#123; var anl=Math.PI*2*a[i] endr=beginr+anl ctx.beginPath() ctx.moveTo(x,y) ctx.arc(x,y,r,beginr,endr,false) ctx.fillStyle=colorlist(); ctx.fill() beginr=endr &#125; &#125; drawPie(100,100,100,arr) function colorlist() &#123; var r=Math.floor(Math.random()*256) var g=Math.floor(Math.random()*256) var b=Math.floor(Math.random()*256) return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)` &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[canvas绘图]]></title>
    <url>%2F2019%2F07%2F30%2Fcanvas%2F</url>
    <content type="text"><![CDATA[#canvas的使用 1.首先创建一个canvas标签，添加一个id“canvas”，添加宽高属性，切记不是行内样式，直接是width=&#39;600&#39; height=&#39;600&#39;这样创建出的canvas标签的宽高与canvas画布的宽高一致，就不会导致出现鼠标与绘画点出现偏差。 1&lt;canvas id="canvas" width="600" height="400"&gt;你的浏览器不支持，请升级浏览器&lt;/canvas&gt; 2.在script中获取canvas元素，并设置为2d画布。 12var canvas = document.getElementById('canvas')var ctx = canvas.getContext('2d') 3.在canvas中线条需要一个起始点和终点，还需要连接起来才成为一条线，下面的例子是平行和交叉。 123456789101112131415ctx.strokeStyle='red'//平行线ctx.moveTo(50, 50.5);ctx.lineTo(200, 50.5)ctx.moveTo(50, 80.5);ctx.lineTo(200, 80.5);ctx.stroke()ctx.beginPath()//交叉线ctx.moveTo(50, 100.5);ctx.lineTo(200, 110.5);ctx.moveTo(50, 110.5);ctx.lineTo(200, 100.5);ctx.strokeStyle='blue'ctx.stroke() 效果图 在上述例子中可以看出，stroke（）方法是进行线条的连接的，并且可以设置样式为红色通过strokeStyle,还可以发现同时设置两种颜色都可以展示出来，这就是beginPath（）方法的作用 4.运用canvas绘制一个三角形 1234567891011 //三角形 ctx.moveTo(50, 50); ctx.lineTo(50, 100.5); ctx.lineTo(200, 75.5); ctx.strokeStyle='blue' ctx.lineWidth=2 ctx.fillStyle='#668204' ctx.closePath() ctx.fill()// ctx.lineTo(50, 50); ctx.stroke() 首先确定一个起点坐标，创建两个终点坐标，猜测是从起点到第一个终点，再将第一个终点当做起点到第二个终点，这样就可以解释为什么闭合三角形的那条线最终指向了开始的起始点。还有方法closePath()会直接闭合,还可以填充颜色fill（），默认为黑色，同样fillStyle设置样式；linewidth设置线条的宽度。 5.设置矩形 12ctx.fillRect(item.x-m/2,item.y,m,y-item.y)ctx.strokeRect(x,y,w,h) 第一种办法是创建四个坐标点连线。第二种就是使用strokeRect()方法有四个参数，前两个是矩形左上角的坐标值（矩形的绘画是以左上角为原点）后两个参数是矩形的宽高。通过fillRect（）同样可以绘制矩形，这种是具有填充色的矩形，与fill（）的相似。 #折线柱状图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function DrawLine(ctx) &#123; this.ctx = ctx || document.getElementById('canvas').getContext('2d') this.m = 10; this.w = this.ctx.canvas.width; this.h = this.ctx.canvas.height; this.x = 50; this.y = 350.5; &#125; DrawLine.prototype = &#123; constructor: DrawLine, init: function (data) &#123; this.drawBg(); this.drawAxis(); this.drawLine(data) &#125;, drawBg: function () &#123; console.log(this); lineX = Math.floor(this.h / this.m); lineY = Math.floor(this.w / this.m); for (i = 1; i &lt; lineX; i++) &#123; this.ctx.moveTo(0, i * this.m + 0.5) this.ctx.lineTo(this.w, i * this.m + 0.5) this.ctx.strokeStyle = "#ccc"; this.ctx.stroke() &#125; for (j = 1; j &lt; lineY; j++) &#123; this.ctx.moveTo(j * this.m + 0.5, 0) this.ctx.lineTo(j * this.m + 0.5, this.h) this.ctx.strokeStyle = "#ccc"; this.ctx.stroke() &#125; &#125;, drawAxis: function () &#123; var x1 = 450, y1 = 50.5; //x this.ctx.beginPath() this.ctx.moveTo(this.x, this.y) this.ctx.lineTo(x1, this.y) this.ctx.lineTo(x1 - this.m, this.y - this.m / 2) this.ctx.moveTo(x1, this.y) this.ctx.lineTo(x1 - this.m, this.y + this.m / 2) this.ctx.strokeStyle = '#000' this.ctx.stroke() //y this.ctx.moveTo(this.x, this.y) this.ctx.lineTo(this.x, y1) this.ctx.lineTo(this.x - this.m / 2, y1 + this.m) this.ctx.moveTo(this.x, y1) this.ctx.lineTo(this.x + this.m / 2, y1 + this.m) this.ctx.strokeStyle = '#000' this.ctx.stroke() &#125;, drawLine(data) &#123; var &#123;ctx,x,y,m&#125;=this ctx.beginPath() ctx.moveTo(x, y) ctx.strokeStyle = 'red' data.forEach((item) =&gt; &#123; ctx.lineTo(item.x, item.y) ctx.lineWidth=2 ctx.fillStyle=this.getrandomColor() ctx.fillRect(item.x-m/2,item.y,m,y-item.y) &#125;) ctx.stroke() &#125;, getrandomColor()&#123; var r=Math.floor(Math.random()*256) var g=Math.floor(Math.random()*256) var b=Math.floor(Math.random()*256) return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)` &#125; &#125; var data = [&#123;x: 50, y: 350.5&#125;, &#123;x: 100, y: 200.5&#125;, &#123;x: 150, y: 300.5&#125;, &#123;x: 230, y: 200.5&#125;, &#123;x: 300, y: 200.5 &#125;, &#123;x: 330, y: 100.5&#125;, &#123;x: 350, y: 50.5&#125;,&#123;x: 400, y: 310.5&#125;] new DrawLine().init(data) 效果图 #总结1.canvas 1px问题，坐标轴位置渲染时，以给出的坐标值为中心，向两边平分，因此给出的坐标最好加0.5，解决1px和2px看起来一样。 2.兼容性问题，在canvas中写出提示。 3.canvas有两套宽高，一个是标签的宽高，一个是画布的宽高；样式的宽高只改变标签的宽高，画布宽高不变；若要都改变，需要在标签内部设置宽高属性，切记不是内联样式。]]></content>
  </entry>
</search>
